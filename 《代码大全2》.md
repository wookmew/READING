#目录  

- [第一章 欢迎进入软件构建的世界](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第一章-欢迎进入软件构建的世界)  
- [第二章 用隐喻来更充分地理解软件开发](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二章-用隐喻来更充分地理解软件开发)  
- [第三章 三思而后行：前期准备](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第三章-三思而后行前期准备)  
- [第四章 关键的“构建”决策](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第四章-关键的构建决策)  
- [第五章 软件构建中的设计](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第五章-软件构建中的设计)  
- [第六章 可以工作的类](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第六章-可以工作的类)  
- [第七章 高质量的子程序](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第七章-高质量的子程序)  
- [第八章 防御式编程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第八章-防御式编程)  
- [第九章 伪代码编程过程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第九章-伪代码编程过程)  
- [第十章 使用变量的一般事项](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十章-使用变量的一般事项)  
- [第十一章 变量名的力量](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十一章-变量名的力量)  
- [第十二章 基本数据类型](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十二章-基本数据类型)  
- [第十三章 不常见的数据类型](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十三章-不常见的数据类型)  
- [第十四章 组织直线型代码](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十四章-组织直线型代码)  
- [第十五章 使用条件语句](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十五章-使用条件语句)  
- [第十六章 控制循环](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十六章-控制循环)  
- [第十七章 不常见的控制结构](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十七章-不常见的控制结构)
- [第十八章 表驱动法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十八章-表驱动法)  
- [第十九章 一般控制问题](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十九章-一般控制问题)  
- [第二十章 软件质量概述](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十章-软件质量概述)  
- [第二十一章 协同构建](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二十一章-协同构建)


> 第一遍阅读中  


# 第一章 欢迎进入软件构建的世界  
软件构建，是重中之重  


# 第二章 用隐喻来更充分地理解软件开发  
- 隐喻即建模，诸如地心说，日心说之类。  
- 对于开发一个不大的项目，增量式开发是首选，即牡蛎的珍珠养殖。而一个大型项目，则需要一开始就仔细地规划，即建房子。 


# 第三章 三思而后行：前期准备  
- 准备工作的中心就是降低风险，在实现一个项目时，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。  
- appeal to Data：原则在于，发现错误的时间要尽可能接近引入错误的时间。  
- 在开始编程之前，确认你的“需求”是否到位。  


# 第四章 关键的“构建”决策  
主要的构建实践：  
- 编码  
- 团队工作  
- 质量保证  
- 工具  


# 第五章 软件构建中的设计  
开发中一般所遇到的问题，都来源于项目的复杂性。软件的首要技术使命就是管理复杂度。用下面两个方法进行复杂度管理：  
&emsp;1. 把任何人在同一时间需要处理的本质复杂度的量减到最少  
&emsp;2. 不要让偶然性的复杂度无谓地快速增长  
设计的层次：  
&emsp;1. 第一层 软件系统  
&emsp;2. 第二层 分解为子系统或包  
&emsp;&emsp;不同子系统之间的相互通信要分隔开  
&emsp;3. 第三层 分解为类  
&emsp;&emsp;如果项目较小，可直接从第一层跳至第三层  
&emsp;4. 第四层 分解成子程序  
&emsp;5. 第五层 子程序内部的设计  

低耦合：耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度  
高内聚：类内部的子程序或者子程序内所有代码在支持一个中心目标上的紧密程度  


# 第六章 可以工作的类  
- 抽象数据类型(ADT, abstract data type)是指一些数据以及对这些数据所进行操作的集合。  
- 创建一个高质量的类，首先要定义一个良好的接口。  
&emsp;1. 当一个类中出现大量子程序时，把这些子程序重新组织，职能相近的分类到一个更专一的类中。  
&emsp;2. 良好的封装。  
- 包含：有一个。。。的关系；继承：是一个。。。的关系。


# 第七章 高质量的子程序  
- 在子程序层上的设计  
&emsp;1. 功能上的内聚性；  
&emsp;&emsp;让一个子程序仅执行一项操作。  
&emsp;2. 顺序上的内聚性；  
&emsp;&emsp;指在子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。  
&emsp;3. 通信上的内聚性；  
&emsp;&emsp;指一个子程序的不同操作使用了相同的数据，但不存在其他任何联系。  
&emsp;4. 临时的内聚性；  


# 第八章 防御式编程  
- 主要思想：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。  
- 三钟方法来处理外来的非法数据：  
&emsp;1. 检查所有来源于外部的数据的值；  
&emsp;2. 检查子程序所有输入参数的值；  
&emsp;3. 决定如何处理错误的输入数据；  
- 断言是用来觉迟绝不应该发生的状况，而错误处理代码来处理预期会发生的状况。  
- 因地制宜的进行防御式编程。  


# 第九章 伪代码编程过程   
- "伪代码"指用来描述算法，子程序，类或完整程序的工作逻辑，非形式的，类似于英语的记法。个人理解，即将设计的逻辑写下来。然后对照着逻辑，去修改，去实现。  


# 第十章 使用变量的一般事项  
- 变量初始化注意以下错误  
&emsp;1. 从未对变量赋值。它的值只是程序启动时变量所处内存区域的值。  
&emsp;2. 变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效。  
&emsp;3. 变量的一部分被赋值，而另一部分没有。  
- 作用域  
&emsp;1. 使变量引用局部化  
&emsp;2. 尽可能缩短变量的存活时间  
- 减小作用域的一般原则  
&emsp;1. 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序开始处初始化这些变量。  
&emsp;2. 直到变量即将被使用时再为其赋值。  
&emsp;3. 把相关语句放到一起。  
&emsp;4. 把相关语句提取成单独的子程序。  
&emsp;5. 开始时采用最严格的可见性，然后根据需要扩展变量的作用域。  


# 第十一章 变量名的力量  
- 变量名要能够完全，准确地描述出该变量所代表的事物。  
- 需要避免的名字：  
&emsp;1. 令人误解的名字或缩写；  
&emsp;2. 具有相似含义的名字；  
&emsp;3. 具有不同含义但却有相似名字的变量；  
&emsp;4. 发音相似的名字；  
&emsp;5. 在名字中使用数字；  
&emsp;6. 在名字中拼错单词；  
&emsp;7. 不要仅靠大小写来区分变量名；  
&emsp;8. 使用多种自然语言；  
&emsp;9. 名字中包含易混淆的字符。  


# 第十二章 基本数据类型  
- 数值概论  
&emsp;1. 避免使用“神秘数值”:(指程序中出现的，没有经过解释的数值文字量)  
&emsp;2. 如果需要，可以使用硬编码的0和1；  
&emsp;3. 预防除零错误；  
&emsp;4. 使类型转换的明显；  
&emsp;5. 避免混合类型的比较；  
- 整数  
&emsp;1. 检查整数除法和溢出；  
&emsp;2. 检查中间溢出；  
- 浮点数  
&emsp;1. 避免数量级相差巨大的数之间的加减运算  
&emsp;2. 避免等量判断；  
&emsp;3. 处理舍入误差；  
- 字符串  
&emsp;1. 避免off-by-one(偏差一)错误，即因索引产生的错误；
&emsp;2. 熟悉unicode转换之类的操作；
- 使用枚举，来代替多个if判断，switch-case之类；  
- 数组  
&emsp;1. 确认数组下标没有超出边界；  
&emsp;2. 考虑用容器来取代数组，或将数组作为顺序化结构来处理(如集合，栈，队列等)；  
&emsp;3. 检查数组边界点；  
&emsp;4. 如果数组是多维的，确认下标的使用顺序是正确的；  
- 创建自定义数据类型的指导原则  
&emsp;1. 给所创建的类型取功能导向的名字；  
&emsp;2. 避免使用预定义类型；  
&emsp;3. 不要重定义一个预定义的类型；  
&emsp;4. 定义代替类型以便于移植；  
&emsp;5. 建议使用一个类；  


# 第十三章 不常见的数据类型  
- 结构体  
Python本身实木有的，但struct模块起到了与C交互的这个功能。  
- 全局变量  
尽量避免使用全局变量，尝试用子程序来取代全局变量。  


# 第十四章 组织直线型代码
- 必须有明确顺序的语句：  
&emsp;1. 设法组织代码，是依赖关系变得非常明显；  
&emsp;2. 使子程序名能凸显依赖关系；  
&emsp;3. 使子程序参数；  
&emsp;4. 利用子程序参数明确显示依赖关系；  
&emsp;5. 用注释对不清晰的依赖关系进行说明；  
&emsp;6. 用断言或者错误处理密码来检查依赖关系；  
- 对于顺序无关的语句：  
&emsp;1. 使代码易于自上而下地阅读；  
&emsp;2. 把相关语句组织在一起；  


# 第十五章 使用条件语句  
- if-else:  
&emsp;1. 把正常情况的处理放在if后面而不要放在else后面；  
&emsp;2. 让if子句后面跟随一个有意义的语句；  
- case语句；  
&emsp;1. 为case选择最有效的排列顺序；  
&emsp;2. 把default子句只用于检查真正的默认情况；  


# 第十六章 控制循环  
- 当不知道要循环迭代多少次时使用while循环，并且决定是在循环开始处还是结尾处检测；  
- 执行固定次数的循环时使用for循环；  
- 关于循环控制：  
&emsp;1. 减少能影响该循环各种因素的数量；  
&emsp;2. 把循环内部当成一个字程序来看待；  
- 进入循环  
&emsp;1. 只从一个位置进入循环；  
&emsp;2. 把初始化代码紧放在循环前面；  
&emsp;3. 用while(true)表示无限循环，Python用while 1比较好;  
&emsp;4. 在适当情况下多使用for循环；  
&emsp;5. 在while循环更实用的时候，不要使用for循环；  
- 循环该有多长：  
&emsp;1. 循环尽可能短，以便能够一目了然；  
&emsp;2. 把嵌套限制在3层以内，如果超过，应该把一部分提取为子程序；  
&emsp;3. 把长循环的内容移到子程序里；  
&emsp;4. 让长循环格外清晰；  


# 第十七章 不常见的控制结构  
- 子程序中多处返回  
&emsp;1. 用防卫子句(早返回或早退出)来简化复杂的错误处理  
&emsp;2. 减少每个子程序中return的数量  
- 递归的使用技巧  
&emsp;1. 确认递归能够停止  
&emsp;2. 把递归限制在一个子程序内  


# 第十八章 表驱动法  
表驱动法是一种编程模式(scheme)---从表里面查找信息而不使用逻辑语句(if和case).  
&emsp;1. 从表中查询数据的方法：  
&emsp;2. 直接访问  
&emsp;&emsp;此处的表并不单指数据库中的表，也可以是一大堆子程序在程序中构成的表；  
&emsp;3. 索引访问  
&emsp;&emsp;即按索引进行快速查询；  
&emsp;4. 阶梯访问  
&emsp;&emsp;表中的记录对不同的数据范围有效，而不是对不同的数据点有效；  


# 第十九章 一般控制问题  
- 布尔表达式  
&emsp;1. 用true和false做布尔判断；  
&emsp;2. 简化复杂的表达式；  
&emsp;&emsp;拆分复杂的判断并引入新的布尔变量；  
&emsp;&emsp;把复杂表达式做成布尔函数；  
&emsp;3. 编写肯定形式的布尔表达式, 即条件判断设为肯定句；  
- 结构化编程  
&emsp;三要素：顺序，选择，迭代  
- 降低复杂度  
&emsp;将子程序的一部分提取成另一个子程序，它不会降低整个程序的复杂度，但可以降低你头脑中考虑项目的数量。  


# 第二十章 软件质量概述  
- 改善软件质量的技术  
&emsp;1. 软件质量目标  
&emsp;2. 明确定义质量保证工作  
&emsp;3. 测试策略  
&emsp;4. 软件工程指南  
&emsp;5. 非正式技术复查  
&emsp;6. 正式技术复查  
&emsp;7. 外部审查  


# 第二十一章 协同构建  
- 协同开发实践概要  
&emsp;协同构建思想在于：工作人员总会对某些错误点视而不见，而其他人不会有相同的盲点。  
- 结对编程  
&emsp;即一位程序员敲代码，一位程序员注意有没有出现错误；  
- 正式检查  
&emsp;详查专注于缺陷的检测，详查表关注复查者过去所遇到的问题；  
 