#目录  

- [第一章 欢迎进入软件构建的世界](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第一章-欢迎进入软件构建的世界)  
- [第二章 用隐喻来更充分地理解软件开发](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第二章-用隐喻来更充分地理解软件开发)  
- [第三章 三思而后行：前期准备](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第三章-三思而后行前期准备)  
- [第四章 关键的“构建”决策](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第四章-关键的构建决策)  
- [第五章 软件构建中的设计](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第五章-软件构建中的设计)  
- [第六章 可以工作的类](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第六章-可以工作的类)  
- [第七章 高质量的子程序](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第七章-高质量的子程序)  
- [第八章 防御式编程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第八章-防御式编程)  
- [第九章 伪代码编程过程](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第九章-伪代码编程过程)  
- [第十章 使用变量的一般事项](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十章-使用变量的一般事项)  
- [第十一章 变量名的力量](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十一章-变量名的力量)  
- [第十二章 基本数据类型]()  
- [第十三章 不常见的数据类型]()
- [第十八章 表驱动法](https://github.com/GJBLUE/READING-/blob/master/%E3%80%8A%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A82%E3%80%8B.md#第十八章-表驱动法)  

> 第一遍阅读中  


# 第一章 欢迎进入软件构建的世界  
软件构建，是重中之重  

# 第二章 用隐喻来更充分地理解软件开发  
- 隐喻即建模，诸如地心说，日心说之类。  
- 对于开发一个不大的项目，增量式开发是首选，即牡蛎的珍珠养殖。而一个大型项目，则需要一开始就仔细地规划，即建房子。 

# 第三章 三思而后行：前期准备  
- 准备工作的中心就是降低风险，在实现一个项目时，你需要理解“这个系统应该做什么”，以及“它该如何做到这些”。  
- appeal to Data：原则在于，发现错误的时间要尽可能接近引入错误的时间。  
- 在开始编程之前，确认你的“需求”是否到位。  

# 第四章 关键的“构建”决策  
主要的构建实践：  
- 编码  
- 团队工作  
- 质量保证  
- 工具  

# 第五章 软件构建中的设计  
开发中一般所遇到的问题，都来源于项目的复杂性。软件的首要技术使命就是管理复杂度。用下面两个方法进行复杂度管理：  
&emsp;1. 把任何人在同一时间需要处理的本质复杂度的量减到最少  
&emsp;2. 不要让偶然性的复杂度无谓地快速增长  
设计的层次：  
&emsp;1. 第一层 软件系统  
&emsp;2. 第二层 分解为子系统或包  
&emsp;&emsp;不同子系统之间的相互通信要分隔开  
&emsp;3. 第三层 分解为类  
&emsp;&emsp;如果项目较小，可直接从第一层跳至第三层  
&emsp;4. 第四层 分解成子程序  
&emsp;5. 第五层 子程序内部的设计  

低耦合：耦合度表示类与类之间或者子程序与子程序之间关系的紧密程度  
高内聚：类内部的子程序或者子程序内所有代码在支持一个中心目标上的紧密程度  

# 第六章 可以工作的类  
- 抽象数据类型(ADT, abstract data type)是指一些数据以及对这些数据所进行操作的集合。  
- 创建一个高质量的类，首先要定义一个良好的接口。  
&emsp;1. 当一个类中出现大量子程序时，把这些子程序重新组织，职能相近的分类到一个更专一的类中。  
&emsp;2. 良好的封装。  
- 包含：有一个。。。的关系；继承：是一个。。。的关系。

# 第七章 高质量的子程序  
- 在子程序层上的设计  
&emsp;1. 功能上的内聚性；  
&emsp;&emsp;让一个子程序仅执行一项操作。  
&emsp;2. 顺序上的内聚性；  
&emsp;&emsp;指在子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。  
&emsp;3. 通信上的内聚性；  
&emsp;&emsp;指一个子程序的不同操作使用了相同的数据，但不存在其他任何联系。  
&emsp;4. 临时的内聚性；  

# 第八章 防御式编程  
- 主要思想：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。  
- 三钟方法来处理外来的非法数据：  
&emsp;1. 检查所有来源于外部的数据的值；  
&emsp;2. 检查子程序所有输入参数的值；  
&emsp;3. 决定如何处理错误的输入数据；  
- 断言是用来觉迟绝不应该发生的状况，而错误处理代码来处理预期会发生的状况。  
- 因地制宜的进行防御式编程。  

# 第九章 伪代码编程过程   
- "伪代码"指用来描述算法，子程序，类或完整程序的工作逻辑，非形式的，类似于英语的记法。个人理解，即将设计的逻辑写下来。然后对照着逻辑，去修改，去实现。  

# 第十章 使用变量的一般事项  
- 变量初始化注意以下错误  
&emsp;1. 从未对变量赋值。它的值只是程序启动时变量所处内存区域的值。  
&emsp;2. 变量值已经过期。变量在某个地方曾经被赋值，但该值已经不再有效。  
&emsp;3. 变量的一部分被赋值，而另一部分没有。  
- 作用域  
&emsp;1. 使变量引用局部化  
&emsp;2. 尽可能缩短变量的存活时间  
- 减小作用域的一般原则  
&emsp;1. 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序开始处初始化这些变量。  
&emsp;2. 直到变量即将被使用时再为其赋值。  
&emsp;3. 把相关语句放到一起。  
&emsp;4. 把相关语句提取成单独的子程序。  
&emsp;5. 开始时采用最严格的可见性，然后根据需要扩展变量的作用域。  

# 第十一章 变量名的力量  
- 变量名要能够完全，准确地描述出该变量所代表的事物。  
- 需要避免的名字：  
&emsp;1. 令人误解的名字或缩写；  
&emsp;2. 具有相似含义的名字；  
&emsp;3. 具有不同含义但却有相似名字的变量；  
&emsp;4. 发音相似的名字；  
&emsp;5. 在名字中使用数字；  
&emsp;6. 在名字中拼错单词；  
&emsp;7. 不要仅靠大小写来区分变量名；  
&emsp;8. 使用多种自然语言；  
&emsp;9. 名字中包含易混淆的字符。  

# 第十二章 基本数据类型  
- 数值概论  
&emsp;1. 避免使用“神秘数值”:(指程序中出现的，没有经过解释的数值文字量)  
&emsp;2. 如果需要，可以使用硬编码的0和1；  
&emsp;3. 预防除零错误；  
&emsp;4. 使类型转换的明显；  
&emsp;5. 避免混合类型的比较；  
- 整数  
&emsp;1. 检查整数除法和溢出；  
&emsp;2. 检查中间溢出；  
- 浮点数  
&emsp;1. 避免数量级相差巨大的数之间的加减运算  
&emsp;2. 避免等量判断；  
&emsp;3. 处理舍入误差；  
- 字符串  
&emsp;1. 避免off-by-one(偏差一)错误，即因索引产生的错误；
&emsp;2. 熟悉unicode转换之类的操作；
- 使用枚举，来代替多个if判断，switch-case之类；  
- 数组  
&emsp;1. 确认数组下标没有超出边界；  
&emsp;2. 考虑用容器来取代数组，或将数组作为顺序化结构来处理(如集合，栈，队列等)；  
&emsp;3. 检查数组边界点；  
&emsp;4. 如果数组是多维的，确认下标的使用顺序是正确的；  
- 创建自定义数据类型的指导原则  
&emsp;1. 给所创建的类型取功能导向的名字；  
&emsp;2. 避免使用预定义类型；  
&emsp;3. 不要重定义一个预定义的类型；  
&emsp;4. 定义代替类型以便于移植；  
&emsp;5. 建议使用一个类；  

# 第十三章 不常见的数据类型  
- 结构体  
Python本身实木有的，但struct模块起到了与C交互的这个功能。  



# 第十八章 表驱动法  
表驱动法是一种编程模式(scheme)---从表里面查找信息而不使用逻辑语句(if和case).  
从表中查询数据的方法：  
- 直接访问  
- 索引访问  
- 阶梯访问  
